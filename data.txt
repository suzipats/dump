import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import java.util.*;
import java.util.concurrent.*;
import java.util.stream.Collectors;

// Class representing the validation result
class ValidationResult {
    private final String message;
    private final boolean isValid;

    public ValidationResult(String message, boolean isValid) {
        this.message = message;
        this.isValid = isValid;
    }

    @Override
    public String toString() {
        return "ValidationResult{message='" + message + "', isValid=" + isValid + '}';
    }
}

// Validator interface
interface Validator {
    ValidationResult validate();
}

// Spring-managed TaskNode class, representing validation tasks with dependencies
@Component
class TaskNode implements Validator {
    private final String taskName;
    private final List<TaskNode> dependencies;  // Dependencies for this task

    public TaskNode(String taskName) {
        this.taskName = taskName;
        this.dependencies = new ArrayList<>();
    }

    public void addDependency(TaskNode dependency) {
        dependencies.add(dependency);
    }

    public List<TaskNode> getDependencies() {
        return dependencies;
    }

    @Override
    public ValidationResult validate() {
        try {
            Thread.sleep(1000);  // Simulate task processing
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        return new ValidationResult(taskName + " validation completed", true);
    }

    @Override
    public String toString() {
        return taskName;
    }
}

@Component
class DependencyGraphValidationProcessor {

    private Map<Integer, List<TaskNode>> tasksByLevel;  // Precomputed tasks by level
    private final List<TaskNode> tasks;  // Injected tasks (Spring beans)

    @Autowired
    public DependencyGraphValidationProcessor(List<TaskNode> tasks) {
        this.tasks = tasks;
    }

    @PostConstruct
    public void init() {
        tasksByLevel = precomputeTaskLevels();
    }

    // Return the first failed ValidationResult or empty if all tasks succeed
    public Optional<ValidationResult> runValidationTasks() {
        for (List<TaskNode> tasksAtLevel : tasksByLevel.values()) {
            Optional<ValidationResult> failedResult = tasksAtLevel.parallelStream()
                    .map(TaskNode::validate)  // Run tasks in parallel
                    .filter(result -> !result.isValid())  // Filter failed results
                    .findFirst();  // Stop as soon as a failure is found

            if (failedResult.isPresent()) {
                return failedResult;  // Return the first failed result
            }
        }
        return Optional.empty();  // Return empty if no failures
    }

    private Map<Integer, List<TaskNode>> precomputeTaskLevels() {
        Map<TaskNode, Integer> indegree = new HashMap<>();
        tasks.forEach(task -> indegree.put(task, 0));

        for (TaskNode task : tasks) {
            for (TaskNode dep : task.getDependencies()) {
                indegree.put(dep, indegree.get(dep) + 1);
            }
        }

        return tasks.stream().collect(Collectors.groupingBy(indegree::get));
    }
}

// Spring Configuration to define TaskNode beans and set up dependencies
@Configuration
class AppConfig {

    @Bean
    public TaskNode taskA() {
        return new TaskNode("Task A");
    }

    @Bean
    public TaskNode taskB() {
        return new TaskNode("Task B");
    }

    @Bean
    public TaskNode taskC(TaskNode taskA) {
        TaskNode taskC = new TaskNode("Task C");
        taskC.addDependency(taskA);  // Task C depends on Task A
        return taskC;
    }

    @Bean
    public TaskNode taskD(TaskNode taskA, TaskNode taskB) {
        TaskNode taskD = new TaskNode("Task D");
        taskD.addDependency(taskA);  // Task D depends on Task A
        taskD.addDependency(taskB);  // Task D depends on Task B
        return taskD;
    }
}

// Main Application
public class SpringDependencyGraphApp {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);

        // Retrieve the validation processor and run the validation tasks
        DependencyGraphValidationProcessor processor = context.getBean(DependencyGraphValidationProcessor.class);
        processor.runValidationTasks();
        
        context.close();
    }
}
