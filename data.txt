import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import java.util.*;
import java.util.concurrent.*;
import java.util.stream.Collectors;

// Class representing the validation result
class ValidationResult {
    private final String message;
    private final boolean isValid;

    public ValidationResult(String message, boolean isValid) {
        this.message = message;
        this.isValid = isValid;
    }

    @Override
    public String toString() {
        return "ValidationResult{message='" + message + "', isValid=" + isValid + '}';
    }
}

// Validator interface
interface Validator {
    ValidationResult validate();
}

// Spring-managed TaskNode class, representing validation tasks with dependencies
@Component
class TaskNode implements Validator {
    private final String taskName;
    private final List<TaskNode> dependencies;  // Dependencies for this task

    public TaskNode(String taskName) {
        this.taskName = taskName;
        this.dependencies = new ArrayList<>();
    }

    public void addDependency(TaskNode dependency) {
        dependencies.add(dependency);
    }

    public List<TaskNode> getDependencies() {
        return dependencies;
    }

    @Override
    public ValidationResult validate() {
        try {
            Thread.sleep(1000);  // Simulate task processing
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        return new ValidationResult(taskName + " validation completed", true);
    }

    @Override
    public String toString() {
        return taskName;
    }
}

// Main Spring Component that processes the validation tasks
@Component
class DependencyGraphValidationProcessor {

    private Map<Integer, List<TaskNode>> tasksByLevel;  // Precomputed tasks by level

    private final List<TaskNode> tasks;  // Injected tasks (spring beans)

    @Autowired
    public DependencyGraphValidationProcessor(List<TaskNode> tasks) {
        this.tasks = tasks;
    }

    // This method is called after the bean is created to precompute the task levels
    @PostConstruct
    public void init() {
        tasksByLevel = precomputeTaskLevels();
    }

    // Method to run the validation tasks at runtime
    public void runValidationTasks() {
        ExecutorService executor = Executors.newFixedThreadPool(4);

        try {
            // Execute the precomputed task levels sequentially
            for (int level = 0; level < tasks.size(); level++) {
                List<TaskNode> currentLevelTasks = tasksByLevel.getOrDefault(level, Collections.emptyList());

                // Execute tasks at the current level in parallel
                List<Future<ValidationResult>> futures = currentLevelTasks.stream()
                        .map(task -> executor.submit(task::validate))
                        .collect(Collectors.toList());

                // Wait for all tasks at this level to complete before moving to the next level
                for (Future<ValidationResult> future : futures) {
                    try {
                        System.out.println(future.get());
                    } catch (InterruptedException | ExecutionException e) {
                        System.err.println("Error executing task: " + e.getMessage());
                    }
                }
            }
        } finally {
            executor.shutdown();
        }
    }

    // Precompute task levels (Topological Sorting)
    private Map<Integer, List<TaskNode>> precomputeTaskLevels() {
        Map<TaskNode, Integer> indegree = new HashMap<>();
        tasks.forEach(task -> indegree.put(task, 0));

        // Calculate in-degrees for all tasks
        for (TaskNode task : tasks) {
            for (TaskNode dep : task.getDependencies()) {
                indegree.put(dep, indegree.get(dep) + 1);
            }
        }

        // Group tasks by dependency level (in-degree)
        return tasks.stream().collect(Collectors.groupingBy(indegree::get));
    }
}

// Spring Configuration to define TaskNode beans and set up dependencies
@Configuration
class AppConfig {

    @Bean
    public TaskNode taskA() {
        return new TaskNode("Task A");
    }

    @Bean
    public TaskNode taskB() {
        return new TaskNode("Task B");
    }

    @Bean
    public TaskNode taskC(TaskNode taskA) {
        TaskNode taskC = new TaskNode("Task C");
        taskC.addDependency(taskA);  // Task C depends on Task A
        return taskC;
    }

    @Bean
    public TaskNode taskD(TaskNode taskA, TaskNode taskB) {
        TaskNode taskD = new TaskNode("Task D");
        taskD.addDependency(taskA);  // Task D depends on Task A
        taskD.addDependency(taskB);  // Task D depends on Task B
        return taskD;
    }
}

// Main Application
public class SpringDependencyGraphApp {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);

        // Retrieve the validation processor and run the validation tasks
        DependencyGraphValidationProcessor processor = context.getBean(DependencyGraphValidationProcessor.class);
        processor.runValidationTasks();
        
        context.close();
    }
}
