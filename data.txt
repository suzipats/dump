import org.springframework.boot.autoconfigure.jdbc.DataSourceProperties;
import org.springframework.boot.context.properties.ConfigurationProperties;

import java.util.HashMap;
import java.util.Map;

import com.zaxxer.hikari.HikariDataSource;
import org.springframework.boot.autoconfigure.jdbc.DataSourceProperties;
import org.springframework.boot.context.properties.bind.Bindable;
import org.springframework.boot.context.properties.bind.Binder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.env.Environment;

import javax.sql.DataSource;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

@Configuration
public class DataSourceConfig {

    private static final String ROOT_PREFIX = "spring.datasource";

    @Bean
    public Map<String, DataSource> dataSources(Environment environment) {
        Binder binder = Binder.get(environment);

        // Get all child property names under spring.datasource.*
        Set<String> dataSourceKeys = binder.bind(ROOT_PREFIX, Bindable.mapOf(String.class, Object.class))
                                           .orElse(new HashMap<>())
                                           .keySet();

        Map<String, DataSource> result = new HashMap<>();

        for (String key : dataSourceKeys) {
            String prefix = ROOT_PREFIX + "." + key;

            // Bind to DataSourceProperties
            DataSourceProperties props = binder.bind(prefix, Bindable.of(DataSourceProperties.class))
                                               .orElseThrow(() -> new IllegalArgumentException("Invalid config for: " + key));

            // Build HikariDataSource
            HikariDataSource ds = props.initializeDataSourceBuilder()
                                       .type(HikariDataSource.class)
                                       .build();

            // Optionally bind Hikari-specific props
            binder.bind(prefix + ".hikari", Bindable.ofInstance(ds));

            result.put(key, ds);
        }

        return result;
    }
}








mport com.zaxxer.hikari.HikariDataSource;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.boot.context.properties.bind.Bindable;
import org.springframework.boot.context.properties.bind.Binder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.env.ConfigurableEnvironment;

import javax.sql.DataSource;
import java.util.HashMap;
import java.util.Map;

@Configuration
@EnableConfigurationProperties(MultipleDataSourceProperties.class)
public class DataSourceConfig {

    @Autowired
    private ConfigurableEnvironment environment;

    @Bean
    public Map<String, DataSource> dataSources(MultipleDataSourceProperties multipleProps) {
        Map<String, DataSource> dataSourceMap = new HashMap<>();

        multipleProps.getDataSources().forEach((name, props) -> {
            // Create HikariDataSource from base props
            HikariDataSource ds = props.initializeDataSourceBuilder()
                                      .type(HikariDataSource.class)
                                      .build();

            // Bind Hikari-specific config
            String prefix = "spring.datasource." + name + ".hikari";
            Binder.get(environment).bind(prefix, Bindable.ofInstance(ds));

            dataSourceMap.put(name, ds);
        });

        return dataSourceMap;
    }
}















import com.zaxxer.hikari.HikariDataSource;
import org.springframework.boot.autoconfigure.jdbc.DataSourceProperties;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.boot.context.properties.bind.Bindable;
import org.springframework.boot.context.properties.bind.Binder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.env.ConfigurableEnvironment;

import javax.sql.DataSource;
import java.util.HashMap;
import java.util.Map;

@Configuration
@EnableConfigurationProperties(DataSourceConfig.MultipleDataSourceProperties.class)
public class DataSourceConfig {

    private final ConfigurableEnvironment environment;

    public DataSourceConfig(ConfigurableEnvironment environment) {
        this.environment = environment;
    }

    @Bean
    public Map<String, DataSource> dataSources(MultipleDataSourceProperties multipleProps) {
        Map<String, DataSource> dataSourceMap = new HashMap<>();

        multipleProps.getDataSources().forEach((name, props) -> {
            // Create HikariDataSource from basic properties
            HikariDataSource ds = props.initializeDataSourceBuilder()
                                      .type(HikariDataSource.class)
                                      .build();

            // Bind Hikari-specific properties
            String prefix = "spring.datasource." + name + ".hikari";
            Binder.get(environment).bind(prefix, Bindable.ofInstance(ds));

            dataSourceMap.put(name, ds);
        });

        return dataSourceMap;
    }

    @ConfigurationProperties(prefix = "spring.datasource")
    public static class MultipleDataSourceProperties {

        private Map<String, DataSourceProperties> dataSources = new HashMap<>();

        public Map<String, DataSourceProperties> getDataSources() {
            return dataSources;
        }

        public void setDataSources(Map<String, DataSourceProperties> dataSources) {
            this.dataSources = dataSources;
        }
    }
}
















@Autowired
private Map<String, DataSource> dataSources;

public void test() {
    DataSource ds1 = dataSources.get("one");
    DataSource ds2 = dataSources.get("two");
    // Use these in JdbcTemplate, JPA, etc.
}
